OAuth2.0允许第三方应用通过HTTP的方式访问特定的资源，巴拉巴拉巴。网上已经有很多的文章介绍OAuth2.0是怎么一回事了。但是今天我为什么要自己写一篇呢？因为在实践中我遇到了问题。

## 起因

在实现与Action on Google对接的时候我遇到了一些问题，具体的可以看我在Stack Overflow上的提问[关于OPEN-AUTH-FAILURE的疑问](https://stackoverflow.com/questions/54341855/to-many-open-auth-failure-in-my-stackdriver?noredirect=1#comment95987322_54341855)，由于这个问题我翻了一下谷歌的文档，发现原先我实现的授权认证和谷歌文档里面写的有出入。然而这个授权认证的流程在几年前就写好了，而且和亚马逊Alexa的对接也很顺利没有出什么认证方面的问题，所以一直就沿用下来了，既然现在出问题了那就认真的学习一下OAuth2.0的协议到底是如何定义的吧。

## OAuth2.0角色

OAuth2.0定义了4个角色，他们分别是：

* **resource owner:**能够授予对受保护资源的访问权限的实体。如果资源所有者是个人的话，那么就是终端用户。    
* **resource server:**持有受保护资源的服务于，外界可通过使用**access token**访问受保护的资源。   
* **client:**使用**source owner**的授权并以它的名义去访问受保护的资源，不特指某种实现。   
* **authorization server:**在**resource owner**认证并授权成功以后颁发**access token**。

## 基本流程
OAuth2.0大体流程如下：

     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

     
* **(A)** **client**请求**resource owner**。授权请求可以直接发送个资源所有者（如上图所示），或者最好以授权服务作为中介。   
* **(B)** **client**收到一个代表**resource owner**认证凭证的授权准许，下文会提到如何使用，具体如何使用取决于**client**的请求方式以及**authorization server**支持哪些方式。
* **(C)** 客户端使用步骤(B)中得到的授权批准向**authorization server**换取**access token**
* **(D)** **authorization server**对**client**进行认证并校验授权准许，如果校验通过则返回**access token**给**client**
* **(E)** **client**使用**access token**作文认证凭证去访问受保护的资源
* **(F)** **resource server**验证**access token**是否合法，如果合法则处理步骤(E)中的访问请求

### Authorization Grant Type

上面步骤(B)中提到的授权批准(authorization grant)基本分为四种，当然支持扩展。

* Authorization Code
* Implicit
* Resource Owner Password Credentials
* Client Credentials

本文讲的就是第一种(**authorization code**)方式，也是OAuth2.0流程步骤(A)与步骤(B)的首选方式。

## Authorization Code Grant

**Authorization Code**类型，被用于获取**access token**和**refresh token**并针对机密客户端做了优化(??)。由于这个过程是基于重定向的，所以**client**一定要能力和**resource owner**的用户代理（user-agent:通常是一个web浏览器）进行交互，并且能够接受来自**authorization server**的请求（通过重定向的方式）。
### Authorization Code流程

     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)

* **(A)** 客户端通过将资源所有者的用户代理指向授权端点来启动整个流程。客户端包括：client identifier、request scope、local state、redirection URI(用于处理**authorization server**的返回结果)
* **(B)** 授权服务器通过资源所有者进行身份验证，资源所有者告知授权服务通过或拒绝客户端的访问请求。
* 